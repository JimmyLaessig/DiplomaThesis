\chapter{Interactions}

Creating new interactions is a key topic for this thesis. This chapter describes the pros and cons of current state-of-the-art two-dimensional interactions and proposes improvements using the detected primitive shapes as interaction support shapes. 

Many proven interaction techniques have emerged over time, such as \textit{Point Picking} or \textit{Region Selection}. 

%% TODO: define pick ray
%% TODO: define candidate global
%% TODO: define point belongs to a shape

\section{Shape Picking and Clustering}




\section{Shape-Assisted Point Filtering}
\label{sec:pointFiltering}

The set of candidate nodes can be created in different ways, depending on the task. However, once a task uses a primitive shape cluster as guide the filtering of points works similar. The set of candidate nodes is further reduced by calculating the intersection of the node's boundingbox with the cluster. For each node, the point set is reduced as well. A point belongs to the shape cluster if it fulfills the score function for this particular shape cluster as described in Section \ref{sec:scorefun}. All points that do not belong to this cluster, are discarded, thus creating a set of points that only consists of support points of the shape cluster. This set of points can then be used for various interactions, described in the following sections. 

\section{Point Picking}
\label{sec:picking}

\textit{Point Picking} describes an interaction, where the user is interested in selecting a single point from the scene at a time. A \textit{pick ray} describes a ray originating from the mouse position whose direction is the view direction. The pick radius $r$ denotes the maximum distance of a point to the pick ray in order for the point to be considered a candidate point. Depending on the use case the pick radius $r$ can be depended on the depth value. There are multiple ways of implementing this interaction with varying results. 
\\
\\
The first explored technique is to use a fixed pick radius in world space. The picked point is the point closest to the pick ray in world space. Since the user only interacts with points that are projected onto the nearplane, the projection of the pick radius is smaller for points that lie in the background. Therefore, the distance in pixel between the mouse position and a picked point in the background is smaller than the distance to a picked point in the foreground. While this encourages the picking of points in the foreground, the non-uniform pixel distance introduces inconsistencies. 
\\
\\
A more consistent way of picking a point is to only use the screen space information for each point. The mouse position $p$ in screen space combined with the pick radius $r$ create the pick circle $c$. This circle corresponds to a projection of a cone. All points that intersect this cone are treated as candidate points. In order to calculate this intersection, all points are projected to the screen space. The cone intersects a point if $c$ contains the point in screen space. Then the point with the projection closest to the mouse position is picked. This technique works consistently for different depth values. However, since all points are treated equally, the technique does not distinguish between foreground and background points, thus introducing possible depth ambiguities. 
\\
The projection of points can be executed on the GPU by rendering the projected points, paired with an identifier, to a texture. From this texture, a window around the mouse cursor is downloaded and the closest point is determined. Reading pixels from a texture forces the CPU and GPU to sync and stalls the graphics pipeline. 
\\
\\
The user interacts with points that are presented on the screen only. Moreover, only points are of interest, whose projection on the nearplane lie in close proximity to the mouse position. Since this interaction cannot be computed for all points in real-time, unneeded octree nodes must be filtered beforehand. This prefiltering can easily be achieved by performing a raycast through the octree and collecting all nodes whose bounding boxes intersect the pick ray. However, consider the case, that the pick ray does not intersect a node's bounding box, but the distance of the box to the ray is smaller than the pick radius. Some points might exist that should be considered candidates, but due to the nature of a raycast, are discarded. This introduces the possibility that points that can be the picking result, are not considered, introducing inconsistency to the pick interaction. One solution to overcome this problem is to use a conecast instead. 
\\
A circle on the nearplane is the projection of a cone in world space. The corners of the box are projected onto the nearplane and the convex hull polygon is calculated. The intersection then is determined by the intersection of the polygon with the pick circle $c$. 



\subsection{Shape-Assisted Point Picking}
\label {picking_assisted}
Picking comes with the disadvantage that some constellations of points can influence the picking interaction in a negative way. Points that occlude structures of interest force the user to change the view in order to pick the desired point. In some cases, a point in the background is favored over a desired point on a structure. 
\textit{Shape-Assisted Point Picking} utilizes primitive shapes to perform the picking routine only on points that are part of a structure. The user selects a cluster of shapes, thus reducing the amount of possible candidate points to only those that belong to this shape. 
\\ 
Instead of using a cone-or raycast result as candidate nodes, only those nodes and points are of interest, that have a relationship with the cluster. The octree nodes and corresponding point sets are filtered as described in section \ref{sec:pointFiltering}, leaving only a handful of nodes and points on which the interaction is performed. 
\\
The pick radius in world space is calculated by unprojecting the pick circle to the intersection point of the pick ray with the shape cluster. Only points are considered that lie in the pick sphere, constructed by the intersection point and the pick radius. The point closest to the intersection point is then picked. Due to the curvature of shapes, such as cylinders and spheres, points on the back of a shape are projected in close proximity to the mouse position as well. By using the projected distances, points that lie on the back side of the shape might get favored over points that are on the front side of the shape (facing the user). 
\\
This technique comes not only with interaction benefits, computation time is drastically reduced as well. Usually a shape cluster consists of less nodes than a raycast since the cluster's extension is limited to a region in the point cloud. Points within a node are also reduced such that intersections and distance measures are computed only for candidate points. 
\\

Figure \ref{fig:picking} shows the different picking methods, described in Section \ref{sec:picking}. Figure \ref{fig:picking_raycast} showcases a simple raycast with a radius. The combination of a ray and a radius yields a cylinder, which contains all candidate points on world space. The pick distance is consistent in world space. Figure \ref{fig:picking_conecast} uses a conecast instead. The opening angle is defined by the pick radius in screen space. The pick distance in world space increases the higher the depth value. All points inside the volume are treated equally, introducing consistency in screen space. Figure \ref{fig:picking_assisted} showcases the use of a support shape to further filter candidate points. All points that belong to the support shape, are filtered prior to be used as input for a spherecast. 

\begin{figure}
\centering
\subcaptionbox{ \label{fig:picking_raycast}}{%
  \includegraphics[width=0.6\textwidth]{Interactions/picking_raycast.png}%7
  }\par\medskip
\subcaptionbox{ \label{fig:picking_conecast}}{%
  \includegraphics[width=0.6\textwidth]{Interactions/picking_conecast.png}%
  }\par\medskip        
\subcaptionbox{ \label{fig:picking_assisted}}{%
  \includegraphics[width=0.6\textwidth]{Interactions/picking_assisted.png}%
  }
\caption{Two-dimensional illustration of various picking methods. Candidate points are colored in green, other points are colored in red. The areas in red describe the different volumes in which candidate points are located. (a) showcases a picking process using a simple raycast. The ray combined with a radius constructs a cylinder in world space which contains all candidate points, (b) uses a cone instead. (c) utilizes a selected shape (dark blue) in order to further filter the candidate points to only follow the curvature of the shape. A spherecast is then performed on the filtered points using the unprojected pick radius as radius to select the final set of candidate points. }
\label{fig:picking}
\end{figure}


\section{Region Selection}

Region Selection aims to not pick a single point at once, but select a set of points, that are spatial neighbors
The design for the \textit{Shape-Assisted Region Selection} is guided by one seemingly simple example task: \textit{Select points that belong to this wall only}. A wall can intersect with other building elements such as roof, balconies or the ground. In regions close to intersections, it is tedious and cumbersome to only select points on the desired structure. Using two-dimensional interaction metaphors, selecting spatially neighboring points along the same curvature, is particularly challenging, since the system does not know the desired depth boundaries for the selection region. In this chapter the benefits of using support shapes for two- and three-dimensional interaction metaphor are discussed. 




\subsection{Lasso Selection}

The \textit{Lasso Selection} is a common two-dimensional interaction metaphor used for multiple geometry-based applications. While it is an effective technique to selected regions in 2D, drawbacks appear when porting the interaction to 3D. The user draws a polygon onto the screen. All points, whose projection lie inside this polygon, are selected. Much like \textit{Point Picking}, points are projected onto the nearplane and and the intersection between the point and the polygon determines if the point is selected. The combination of a two-dimensional polygon and the projection of points describes an three-dimensional area. The polygon is extruded in the view direction up to a user-defined distance. All points that lie within this volume are selected. Figure \ref{fig:lasso_sketch} showcases the volume created by a lasso polygon drawn onto the screen.

Note that this interaction is performed asynchronously and the complete octree is consulted. Therefore, it is essential that octree nodes, whose LoDs are too high and therefore are not rendered, are still included in this interaction as well. 


\begin{figure}
	\centering
	\includegraphics[width=0.8\textwidth]{Interactions/lasso_sketch.png}%7
	\caption{The user draws a polygon(red) on the screen(light blue). The constructed three-dimensional area(yellow) contains all points, whose projection lie inside the lasso polygon. }
	\label{fig:lasso_sketch}
\end{figure}


\begin{figure}
\centering
\subcaptionbox{ \label{fig:lasso1}}{%
  \includegraphics[width=0.5\textwidth]{Interactions/lasso1.png}%7
  }\par\medskip
\subcaptionbox{ \label{fig:lasso2}}{%
  \includegraphics[width=0.5\textwidth]{Interactions/lasso2.png}%
  }\par\medskip        
\subcaptionbox{ \label{fig:lasso3}}{%
  \includegraphics[width=0.5\textwidth]{Interactions/lasso3.png}%
  }
	
\caption{(a) - (c) show a lasso selection performed on a point cloud. In (a) the user draws a polygon onto the screen. In (b) the selected points are visualized in red. Figure (c) showcases the selection from a different angle. All points that are projected to the area of the polygon, are selected.The unintentional selection of points that are obscured by objects in the foreground is a byproduct of the \textit{Lasso Selection}. }
\label{fig:lasso}
\end{figure}


Figure \ref{fig:lasso} shows a lasso selection performed on a point cloud. The user draws a polygon onto the screen. The selected points are highlighted in red. When changing the view, selected points that where occluded when drawing the lasso, appear. The user must control the selection distance by hand in order to minimize this effect. However, the in order to solve the task of only selecting points on the wall, further lasso selections must be used to remove points from the selection that where selected unintentionally. 



\subsection{Shape-Assisted Lasso Selection}
The aim of this interaction is to provide a smaller set of points on which a \textit{Lasso Selection} is performed.  To reduce the number of candidate nodes and discard points that do not belong the the selected shape cluster, the octree nodes are again filtered using the technique described in Section \ref{sec:pointFiltering}. On this reduced set a \textit{Lasso Selection} is performed. The result of this interaction is a selection that mimics a \textit{Lasso Selection}, with the benefit of not selecting 'through' the point cloud. The depth ambiguities of the \textit{Lasso Selection} are circumvented by introducing a min-max depth range defined by the local curvature of the shape cluster. 

Figure \ref{fig:lasso_assisted} shows the workflow for selecting points on a shape. The shape is selected beforehand by the user. A lasso is drawn on the screen which selects all points that lie within the lasso and belong to the selected point cluster. In Figure \ref{fig:lasso_assisted3}, it can be seen that, contrary to Figure\ref{fig:lasso3}, no points that were occluded while drawing the lasso, are selected. 

\begin{figure}
\centering
\subcaptionbox{ \label{fig:lasso_assisted1}}{%
  \includegraphics[width=0.5\textwidth]{Interactions/lasso_assisted1.png}%7
  }\par\medskip
\subcaptionbox{ \label{fig:lasso_assisted2}}{%
  \includegraphics[width=0.5\textwidth]{Interactions/lasso_assisted2.png}%
  }\par\medskip        
\subcaptionbox{ \label{fig:lasso_assisted3}}{%
  \includegraphics[width=0.5\textwidth]{Interactions/lasso_assisted3.png}%
}
\caption{(a) - (c) show a \textit{Shape-Assisted Lasso Selection} performed on a point cloud. The front facing wall is selected as support shape by the user. The shape cluster is visualized in light red. In (a) the user draws a polygon onto the screen after selecting a shape as support shape. (b) shows the selected points visualized in red from the same point of view. Upon view change, it can be seen that this interaction only selects points that belong the the shape cluster. }
\label{fig:lasso_assisted}
\end{figure}


\subsection{Volumetric Brush}

The \textit{Volumetric Brush} by Weyrich et. al\cite{weyrich2004post} is designed in such a way that a volume is projected onto the foremost geometry. Points that intersect this volume are considered to be selected. To retrieve the projected position of the volume, usually a sphere, the depth buffer is consulted and the depth value for the current mouse position is retrieved. The world position is the unprojection of the mouse position's $xy$-coordinates and the depth value. 
\\
Since this technique follows the foremost geometry only, sudden depth changes occur if the area of interest is occluded by different geometry. Thus view changes are still required to achieve the example task. In regions close to intersections with other structures, such as below the roof, the user must control the size of the volume in order to not select points on neighboring structures. 


\subsection{Shape-Assisted Volumetric Brush}
The \textit{Volumetric Brush} can easily adapted to be used in combination with support shapes. Instead of consulting the depth buffer to reconstruct the cursor’s world position, the pick ray is intersected with the selected support shape, thus resulting in a three-dimensional world position. The selection is then performed only on the filtered set of points as described in Section \ref{sec:pointFiltering}. 
Figure \ref{fig:brush} shows a \textit{Shape-Assisted Volumetric Brush} interaction performed on a wall. The wall is describes as a cluster of planes. Only points are selected that belong to the shape cluster. 

\begin{figure}
\centering
\subcaptionbox{ \label{fig:lasso_assisted1}}{%
  \includegraphics[width=0.8\textwidth]{Interactions/brush1.png}%7
  }\par\medskip
\subcaptionbox{ \label{fig:lasso_assisted2}}{%
  \includegraphics[width=0.8\textwidth]{Interactions/brush2.png}%
  }
\caption{This figure shows a \textit{Shape-Assisted Volumetric Brush} selection performed shape cluster (transparent red) detected in a point cloud. In (a) the trajectory of the brush is shown as subsequently rendered spheres(grey). (b) shows the selected points for this brush interaction. Even tough some points of the roof structure are intersecting the brush, they are not selected. }
\label{fig:brush}
\end{figure}



\section{Shape-Assisted Local Level-of-Detail Increment}

To further investigate the local structures of a point cloud, the currently rendered maximum level-of-detail might not suffice. The level-of-detail is controlled by the system as such, that the GPU is busy but not overloaded and the balance between detail and performance is retained. However, temporarily adding a handful of additional nodes is sufficient enough to provide more detailed information, that can be presented without a huge impact in performance.
\\

Section \ref{sec:renderHorizon} describes the set of nodes that are still rendered, but where some of the children are not rendered anymore, as \textit{render horizon}. 
Increasing the level-of-detail is only useful for nodes that lie on the \textit{render horizon}, since beyond these nodes more detailed information exists that is currently not rendered. A raycast is performed on the render horizon. All nodes that intersect the ray are, again, considered to be candidate nodes. The successor nodes of the candidate nodes hold more detailed information on the region of interest. Depending on a \textit{level-of-increment} parameter, controlled by the user, the successors of those nodes are added to the scene and rendered. A \textit{level-of-increment} value of $1$ results in adding all children for each node on the render horizon, a parameter of $2$ results in adding all children's children to the scene. 
By adding smaller nodes of higher level-of-detail, the overall detail in the scene is amplified. However, by simply adding additional nodes, noise and unwanted structures are amplified as well. 
\\

\textit{Shape-Assisted Local Level-of-Detail Increment} utilizes a selected shape cluster to amplify detail only on structures of interest. The user selects a primitive shape as support shape. Instead of performing a raycast, the nodes on the render horizon that intersect the support shape, are collected. From these nodes, only those are added to the scene that belong to the support shape, determined by the score function describes in Section \ref{sec:scorefun}. 

